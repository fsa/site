---
layout: post
title: "PHP: от старта до фреймворков"
date: 2023-02-07 23:48:00 +0700
tags: [MySQL, PostgreSQL]
excerpt: Эта обзорная статья, которая появилась благодаря собственному опыту изучения PHP. В ней я расскажу о шагах, которые приблизили меня от самого начала к пониманию фреймворков. Это, скорее, погружение в мою личную историю, но я постараюсь привести примеры, в том числе практические, чтобы эта статья была бы быть полезной и для вас.
---
PHP — это довольно популярный язык программирования. Много лет в интернете можно услышать утверждение, что PHP умирает. Однако язык до сих пор жив и активно используется. Если вы занимаетесь выбором языка для изучения в 2024 году, возможно, вам стоит обратить внимание на другие языки программирования. Но если вы всё-таки решились и начали осваивать PHP, то эта заметка для вас.

PHP преимущественно используется для разработки веб-приложений, точнее даже серверной их части, которую обычно называют бэкендом. Это означает, что ваш код будет работать на сервере. Это несколько упрощает вам задачу, поскольку вам нужно заботиться только о том, чтобы ваше приложение работало только с определёнными версиями PHP, которые доступны на вашем сервере, а не адаптировать ваш код под множество версий браузера, чем вынуждены заниматься фронтенд разработчики.

Но даже не смотря на узкую специализацию языка его всё-таки можно использовать и в других сферах, хоть и не так эффективно. Например, вполне можно писать приложения для десктопа.

PHP всегда привлекал к себе за счёт низкого порога входа. Код на PHP прощает многие ошибки, которые не прощают другие языки. Вы можете часами разбираться почему ваше первое приложение не хочет запускаться, если будете писать на Java или Python. В PHP обычно проблем у начинающих возникает намного меньше. Это и достоинство и недостаток языка. Вы очень быстро сможете начать разрабатывать свои приложения, но позже, вам всё равно придётся столкнуться с изучением основ, которые, в тех же Java и Python просто обязательны с первого дня.

## Объектно ориентированный подход

Итак. Вы уже написали свой первый «Hello, World» на PHP и, возможно, даже пишите какие-то длинные скрипты, которые проводят некие магические вычисления. Чем больше данных, тем более запутанных становится ваш код. Вы постоянно вынуждены копировать куски одного и того же кода, чтобы выполнить одно и тоже действие в другом месте.

Постепенно приходит понимание что такое функция и мы начинаем переносить в них повторяющиеся куски кода. Теперь вместо

```php
echo 4 * 6 + 7;
...
echo 12 * 3 + 20;
...
echo 22 * 24 + 100;
```

в нашем коде появляется что-то вроде такого:

```php
calc(4, 6, 7);
...
calc(12, 3, 20);
...
calc(22, 24, 100);
...
function calc($a, $b, $c) {
    echo $a * $b + $c;
}
```

И пусть теперь нас ругают более опытные коллеги, что мы написали плохой код, но теперь мы, как минимум, не будем бегать по всему коду, искать нашу формулу и исправлять её, если заходим вместо этих операций с тремя значениями сделать что-то другое. А если у нас что-то сложнее простых арифметических действий, то нам теперь не нужно постоянно копировать этот самый кусок кода по всей программе, а просто вызвать нашу функцию.

Двигаемся дальше и видим, что наш код обрастает огромными структурами, которые мы из раза в раз повторяем. Если нам нужно куда-то передать информацию о человеке, то мы используем массивы, например, так:

```php
$user = array(
    "name" => "Саша",
    "birthday" => "2001-03-08",
    "contacts" => array(
        "phone" => "555-55-55",
        "email" => "sasha@example.org"
    )
);
```

Вроде бы и всё понятно. Но эти структуры норовят вырасти в объёме. В них то и дело появляются новые поля и приходится снова и снова бегать по всему коду и искать, где есть подобные конструкции и редактировать их. Ещё и многоуровневые массивы, когда чтобы добраться до нужной информации нужно указать несколько квадратных скобок после имени массива чтобы добраться до нужных данных. Забыл один уровень и нужных данных у тебя нет. Ещё хуже, начинают вылезать всякие предупреждения. Жизнь потихоньку превращается в ад.

И тут мы узнаём о чудодейственных классах, куда мы не только можем перенести все наши ценные данные, но ещё и перенести в них наши функции, которые связаны с этими данными. Например, чтобы вычислить возраст, мы находим решение на каком-нибудь StackOverflow или через ИИ, делаем функцию getAge, и у нас получается что-то вроде такого:

```php

$contacts = new Contacts;
$contacts->phone = "555-55-55";
$contacts->email = "sasha@example.org";
$user = new User;
$user->name = "Саша";
$user->birthday = "2001-03-08";
$user->contacts = $contacts;

class User
{
    public $name;
    public $birthday = null;
    public $contacts;

    public function getAge()
    {
        if ($this->birthday) {
            $birthday = new \DateTime($this->birthday);
            $interval = $birthday->diff(new \DateTime());
            return $interval->y;
        }
        return false;
    }
}

class Contacts
{
    public $phone;
    public $email;
}
```

Довольно многословно, но теперь наша IDE нам начинает подсказывать что и как называется. Уже не нужно держать в памяти всю структуру данных, достаточно просто воспользоваться подсказками. Если нам нужен телефон, то мы просто пишем

```php
$phone = $user->contacts->phone;
```

Наши старшие коллеги втирают нам что-то про инкапсуляцию, про чёрный ящик, сеттеры, геттеры... Но наша задача решается и код работает.

Теперь мы знаем, что есть классы. Что в эти классы можно свои переменные, которые называются свойствами и вкладывать функции, которые называются методами. Теперь мы вместо вереницы параметров функции или метода просто передаём объект нужного класса, который содержит все необходимые данные.

Дальше, возможно вы узнаётся про статические переменные и методы. Изучаете наследование и прочее.

## Всемогущий composer

Вы успешно развиваете свои проекты, но начинаете понимать. Количество классов растёт с неимоверной скоростью. Вы уже сами путаетесь что и где подключать. Самое логичное, что вы могли придумать, класть один класс в отдельный файл. Но их стало на столько много, что от вереницы `require` рябит в глазах. Нужно что-то с этим делать.

В интернете вы узнаёте про автозагрзку классов, про некий «composer». Наверно что-то сложное. Ищем как можно автоматически загружать классы. PHP всегда мог загрузить любой файл из указанных ему каталогов в `include_path`. Также есть описание, что можно написать свою функцию для автозагрузки. Немного исследуем вопрос и получаем следующий код, который размещаем в файле, который расположен в каталоге вместе с другими классами.

```php
set_include_path(__DIR__);
spl_autoload_extensions('.php');
spl_autoload_register();
```

Здесь `set_include_path` задаёт путь, где будет производиться поиск файлов с классами, `spl_autoload_extensions` задаёт хвост для имени файла, который будет добавлен к имени класса, `spl_autoload_register` регистрирует автозагрузку классов. Увы, но данный код позволяет загружать классы только если в имени файлов все символы имени класса переведены в нижний регистр. Как это можно исправить? Написать свою функцию автозагрузки.

Тут мы узнаём о пространствах имён (`namespace`) и наш код автозагрузки классов из простого подключения класса превращается в какую-то уже довольно приличного размера функцию. И этот код придётся везде копировать.
