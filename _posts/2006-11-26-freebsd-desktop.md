---
layout: post
title: Установка FreeBSD в качестве рабочей станции
redirect_from:
  - /FreeBSD/desktop/
  - /FreeBSD/desktop/ar01s02.html
  - /FreeBSD/desktop/ar01s03.html
  - /FreeBSD/desktop/ar01s04.html
  - /FreeBSD/desktop/ar01s05.html
  - /FreeBSD/desktop/ar01s06.html
  - /FreeBSD/desktop/ar01s07.html
  - /FreeBSD/desktop/ar01s08.html
date: 2006-11-26 20:00:00 +0500
lastmod: 2022-08-08 23:59 +0500
tags: [FreeBSD]
excerpt: Приведён опыт настройки FreeBSD для использования в качестве рабочего компьютера. Статья была изначально написана в 2006 году, но была доработана в 2010 году. Перенесена в блог в 2022 году без изменений содержания. В настоящее время статья утратила свою актуальность.
---
Текущий вариант статьи всегда доступен по адресу <https://tavda.net/freebsd-desktop>. При использовании материалов статьи ссылка на вышеуказанный ресурс обязательна.

Эта статья никоим образом не претендует на звание подробного руководства по настройке FreeBSD. В ней будут изложены вопросы установки FreeBSD для использования в качестве desktop среды, а также описаны подводные камни с которыми я сталкивался при настройке системы. Получить развёрнутые описания по конкретным моментам настройки можно из нескольких официальных источников:

* man - это основной источник документации. Чтобы узнать подробности, достаточно в командной строке набрать man название_команды и вы получите развёрнутое описание как её использовать. Знание английского обязательно, т.к. практически все маны написаны на нём.

* handbook - один из разделов сайта <http://www.freebsd.org/>. Русскоязычный handbook расположен по адресу <http://www.freebsd.org/doc/ru_RU.KOI8-R/books/handbook/>. Содержит ответы практически на все вопросы. Если вы говорите, что там этого нет, просто внимательней ищите! Знания английского в данном случае не требуется, только если вы не захотите узнать о новинках, т.к. сначала их описание появляется в англоязычном handbook.
* examples - несколько папок в вашей файловой системе: `/usr/share/examples`, `/usr/local/share/examples/`. Папки содержат примеры конфигурационных файлов для приложений, установленных в системе. Как правило примеры снабжены подробными комментариями, что очень упрощает конфигурирование. Опять таки требуется знание английского языка!!!

Всё, что описано ниже было проделано мною на версии FreeBSD-6.1. Последняя редакция этой документации производилась на FreeBSD-8.0.

История версий: 26.11.2006, 01.07.2007, 10.03.2010.

## Глава 1. Установка ядра системы и первоначальная настройка.

Итак. Диск FreeBSD в приводе, загрузка с CD включена и вот началась загрузка системы с CD. Самым первым вопросом при загрузке является режим запуска. Собственно говоря нас пока это мало интересует, поэтому просто нажимаем Enter или ждём когда истекут 10 секунд. Далее нам необходимо ответить на два вопроса, касаемо страны, где мы находимся и кодировки:

* `Country Selection`, соответственно выбираем `182 Russian Federation`.
* `System Console Keymap`, выбираем `Russia KOI8-R`.

Конечно вы можете выбрать что-то более подходящее для вас. Кстати, выбор KOI8-R не случаен. Несмотря на то, что в кругах Linux чаще используется UTF-8, для начинающих во FreeBSD лучше оставить KOI8-R. Исходный код ещё недостаточно доработан для корректной поддержки UTF-8. Будьте готовы к тому, что консоль может некорректно отображаться. В интернете вы можете найти несколько методов как получить более или менее полноценную поддержку UTF-8, но, к сожалению, в настоящий момент все из них могут иметь некоторые побочные эффекты.

После всех вышеописанных подготовительных действия мы попадаем, собственно, в главное меню установки и настройки системы - `sysinstall`. Попасть в эту утилиту после установки системы можно всегда просто набрав в командной строке `sysinstall`. `sysinstall` поможет нам установить систему и произвести основные настройки после установки.

Итак, приступаем к установке системы. Надеюсь вы позаботились заранее о свободном месте на вашем жёстком диске или вообще об отдельно диске для вашей FreeBSD. Нам на выбор предлагают три варианта установки системы: `Standard`, `Express`, `Custom`. Мы не из робкого десятка, поэтому выбираем `Custom` (остальные методы установки можно задать в качестве домашнего задания). После выбора попадаем в следующее меню.

В данном меню представлены все стадии установки системы на ваш HDD:

* `Options` - в этой части мы можем указать различные опции при установке системы. Для начинающих я бы порекомендовал пока не обращать внимание на этот пункт, что мы собственно и делаем. Если вы хотите всё-таки познакомиться с содержимым Options, милости просим. Для завершения нажмите Q.
* `Partition` - в этой части мы собственно создаём слайс (в терминологии Windows - раздел), где будет размещаться наша FreeBSD. Разбивка HDD здесь не совсем стандартна. В одном слайсе можно создать несколько разделов (именно поэтому различается терминология). Работать в этом разделе нужно очень внимательно, т.к. из-за своих ошибок можно потерять другие разделы на HDD. Собственно говоря никогда не видел ничего сложного в этой процедуре, однако знакомые умудрялись уничтожить раздел с установленной Windows и кучей нужных данных. Так или иначе, советую выбрать unused часть диска, после чего нажать кнопку C. В ответ вам предложат выбрать размер вашего будущего слайса, который по умолчанию равен величине свободного пространства на диске. При желании вы можете изменить этот размер и оставить ещё немного свободного места. Размер можно указывать в блоках, мегабайтах или гигабайтах (в последних двух случаях необходимо после размера указать букву M или G). После выбора размера нас попросят выбрать тип слайса, выбираем значение по умолчанию 165. Собственно для установки системы нам достаточно одного слайса. Перед выходом убеждаемся, что разделы других систем, как то NTFS и прочие мы видим, после чего можно нажимать кнопку Q для выхода из этого меню.

    Далее мы попадаем в меню Install Boot Manager.

    Вообще, в стандартной поставке FreeBSD имеется 2 типа загрузочных записей: BootMgr и Standard. Первая как видно из названия представляет из себя менеджер загрузки с помощью которого можно загружать также другие операционные системы с ваших HDD. Второй тип загрузчика Standard загружает только FreeBSD, это самый подходящий вариант для тех, у кого будет только FreeBSD или FreeBSD устанавливается на отдельный HDD.</para>

    Если в системе имеется несколько HDD, то вам предложат выбрать диски, на которые вы ходите установить загрузчик FreeBSD. Если у вас уже установлен какой-то удобный вам загрузчик, умеющий загружать различные системы, можно ничего не устанавливать. Если FreeBSD устанавливается на второй диск в системе, то рекомендую на этом диске поставить загрузчик типа Standard, а на основном поставить BootMgr или свой загрузчик. При желании можно заставить загружать FreeBSD загрузчиком от Windows 2000/XP, но это дело чревато, если вы что-то не так сделаете, можете потерять раздел Windows. Так что оставим эти эксперименты для особо любопытных, почитать подробнее можно в handbook на сайте www.freebsd.or g. Собственно говоря, на этом разметка диска закончена.
* `Label` - создание разделов в слайсе. На предыдущем этапе мы подготовили слайс для наших разделов, теперь займёмся непосредственно их созданием. Надо сразу отметить различие между Windows/MS-DOS и Linux/BSD. В ОС *nix файловая система состоит из одного корневого раздела, остальные файловые системы монтируются в папках. Кстати, подобная система появилась и в Windows 2000, но она завуалирована наличием дисков C: D: и т.д., которые по сути являются ссылками на определённые папки корневой файловой системы.

    Итак, выберем самый простой путь разметки - автоматический. Для этого выбираем в верхней части меню нужный диск и слайс в нём, после чего нажимаем кнопку A. При этом создаются следующие разделы:

    / - корневой раздел типа UFS2, размер его обычно 512Mb. Это основной раздел, единственный, который монтируется в аварийных случаях. Содержит в себе ядро операционной системы, жизненно важные команды (например, проверки диска), а также конфигурационные файлы.

    swap - своп операционной системы, если в Windows он представляет из себя файл, то в данном случае это отдельный раздел типа SWAP, объём его выбирается исходя из размера оперативной памяти. Можно согласиться с выбором системы, но у меня он составляет 1,5Гб :-) (т.к. у меня 1Гб оперативной памяти). Обычно я его уменьшаю до меньшего размера, т.к. даже этот гигабайт при работе очень сложно забить, это не Windows. Например в момент написания этих строк у меня запущен Firefox 2.0 с несколькими вкладками, SIM-IM, XMMS, KGet, системный монитор KDE, но пик загрузки оперативной памяти не превышает 600Мб, при этом своп файл вообще не используется.

    /var - раздел для размещения постоянно меняющихся данных. В него обычно помещается база почтового сервера, базы SQL и другая информация, которая часто модифицируется. Так то, если вы планируете установить у себя MySQL сервер, то позаботьтесь о выделении необходимого места под вашу базу данных. Раздел имеет тип UFS2+S, размер по умолчанию 1139Mb.

    /tmp - радел для размещения временных файлов, которые создаю приложения. Сделано это для того, чтобы не замусоривать основные файловые системы и, соответственно, увеличивать степень фрагментации файлов. Тип файловой системы UFS2+S, размер по умолчанию 512Mb, хотя можно подумать и об его увеличении, так например вы уже не сможете просматривать большие архивы через Midnight Commander, т.к. он распаковывает их перед просмотром именно в этот раздел. С другой стороны распаковка проиходит очень долго :-)

    /usr - основной пользовательский раздел, тип файловой системы UFS2+S. По умолчанию занимает всё свободное пространство в слайсе. Здесь будут размещаться весь устанавливаемый софт и ваши документы (/usr/home)

    Иногда имеет смысл создать ещё дополнительные разделы, при этом уменьшив раздел /usr. Например, если вы хотите использовать свой компьютер как файл-сервер на базе Samba, то имеет смысл выделить каталог /home в отдельный раздел, для которого включить дополнительные возможности файловой системы.

    Если же вы всё-таки решились создать разделы по вашему выбору, то делается это следующим образом. Выбираем сверху нужный слайс, после чего нажимаем кнопку C. Далее нас просят указать размер раздела. Указать его можно в блоках (указывается количество блоков числом), гигабайтах (при этом после размера ставится буква G), мегабайтах (указываем букву M), или цилиндрах (указываем букву C). Далее необходимо выбрать тип файловой системы, собственно говоря выбирать не из чего, имеется только FS (A file system) и Swap (A swap partition). Swap, как понятно из названия, используется только для раздела Swap. Все остальные разделы должны быть типа FS. Завершающая стадия создания раздела - указание точки монтирования.

* `Distributions`. Перейдём непосредственно в выбору основных компонентов нашей операционной системы. Это первый пункт, к которому вы можете вернуться после установки системы. Правда, если вы забудете установить важные компоненты системы, вы просто не сможете загрузить систему :-)

    Итак, перейдём к выбору компонентов. Снова выбираем Custom, ведь мы не боимся трудностей, тем более, что в этом случае мы сможем контролировать то, что будет установлено. Вот список компонент:

  * base - binary base distribution - базовый набор компонентов, обязателен для установки, иначе вы просто не сможете работать!!!
  * kernels - ядро операционной системы, также обязательный компонент системы!!! В старых версиях предлагалось два варианта: GENERIC или SMP (GENERIC symmetric multiprocessor kernel configuration). SMP вам пригодится в случае использования многопроцессорных систем или двухядерных процессоров, в остальных случаях выбираем GENERIC. В новых версиях GENERIC также научился работать с несколькими процессорами или ядрами процессора.
  * dict (Spelling checker dictionary files) - словари, используются для проверки орфографии. Можно не устанавливать, тем более, что здесь установятся только англоязычный словарь.
  * doc (Miscellaneous FreeBSD online docs) - набор документации. Можно не устанавливать, т.к. это англоязычная документация.
  * games (Games (non-commercial) - некоммерческие игры, можно не устанавливать.
  * info (GNU info files) - info файлы GNU, можно не устанавливать.
  * man (System manual pages) - документация для компонентов системы, рекомендую установить, несмотря на том, что все описания на английском языке.
  * catman (Preformatted system manual pages) - набор программ, для работы с документацией man.
  * proflibs (Profiled versions of the libraries) - набор дополнительных библиотек. Для чего конкретно они нужны не разбирался, обычно ставлю.
  * src (Sources for everything) - исходный код всех компонентов системы, рекомендую поставить всё, т.к. в будущем мы попробуем создать установить своё ядро, а также обновлять систему до текущего состояния.
  * ports (The FreeBSD Ports collection) - коллекция портов. Очень удобный механизм установки приложений для FreeBSD. По сути это каталог всевозможного софта с описанием автоматизированной установки. Рекомендую поставить!!!
  * local (Local additions collection) - так и не разобрался для чего это.
  * X.org (The X.Org distribution) - графический сервер, которые используют практически все графические оболочки для *nix для прорисовки окон и других графических элементов. Если вы планируете использовать графическую оболочку на своём компьютере (а мы сейчас устанавливаем именно desktop), то рекомендую установить все компоненты X.org. Существует также другая реализация этого сервера XFree, но от него отказались в пользу Xorg в одной из предыдущих версий FreeBSD.

После выбора необходимых компонентов, выходим в наше установочное меню:

* `Media` - выбор источника установочных файлов. Поскольку вы ставите систему в первый раз, то используете CD/DVD, который собственно и выбираем. Обратите внимание на многообразие источников установки. Благодаря такому выбору опытные пользователи могут производить установку по сети, не используя монитора, клавиатуры и сменных приводов.
* `Commit`. Итак, мы дошли до пункта, где начинается непосредственно внесение всех изменений в файловой системе и установка компонентов. Сразу же после выбора этого пункта нам показывают предупреждение, что это последний шанс отказаться от установки, иначе все изменения в структуре слайсов на диске будут применены. Соглашаемся, что мы готовы продолжать.

Теперь можно откинуться на спинку кресла или сходить приготовить себе кофе.

По окончании установки вам будет предложено посетить главное меню `sysinstall` для дополнительной настройки вашей системы. Мы этого делать не будем и просто откажемся, т.к. все настройки можно будет сделать после первой загрузки системы с HDD.

Завершаем установку выбрав Exit install. Перед перезагрузкой нас предупредят, что необходимо убрать все сменные носители с которых может произойти загрузка. Можно этого не делать, если во время перезагрузки заглянуть в Setup вашего компьютера и указать загрузку с HDD.

Итак, во время перезагрузки не забывает отключить загрузку с CD. После перезагрузки проверяем все ли наши операционные системы загружаются правильно, после чего вы можете загрузить FreeBSD.

Итак, перезагрузка прошла успешно и вы получили приглашение login. Поздравляю вас! С самым сложным этапом вы справились, теперь ничего не угрожает операционным системам на вашем компьютере :-)

Приступим к дальнейшему конфигурированию системы. Входим в систему под пользователем root, т.е. самым главным пользователем в системе. Не рекомендую его использовать при работе в системе, а использовать только для конфигурирования системы и установке новых приложений.

После входа в систему набираем `sysinstall` и попадаем в знакомое нам меню. На этот раз нас интересует пункт меню Configuration.

Сразу задаём Root Password, особенно если в дальнейшем ваш компьютер будет иметь выход в сеть. От этого действия зависит безопасность вашей системы.

В отрытом меню мы также видим знакомый пункт Distribution - компоненты системы. Если мы забыли что-то установить при установке, здесь вы всегда сможете это добавить.

Раздел Packages - это комплект скомпилированных приложений, которые разработчики поместили на дистрибутивные диски. Вы можете установить нужные вам программы отсюда, либо непосредственно с ftp сервера <ftp://ftp.freebsd.org> (несомненно в этом случае вы получите наиболее свежие версии программ).

С пунктом Root Password мы уже знакомы, это задание пароля пользователя root.

Пункты Fdisk и Label мы использовали при установке, если вы не собираетесь изменять разметку на дисках, то не советую эти пункты использовать, т.к. при невнимательном использовании вы можете потерять данные на имеющихся разделах.

Раздел User Management. Здесь вы можете создать новых пользователей, при этом будут созданы все необходимые пользовательские папки (обычно они создаются в папке /home, которая по умолчанию является ничем иным как символический ссылкой на папку /usr/home). Рекомендую создать вам хотя бы одного пользователя. При создании пользователя также будет создана группа с таким же именем, поэтому добавлять группы нет необходимости.

При создании пользователя нам необходимо ввести:

* Login ID: имя пользователя;
* UID: идентификатор пользователя, лучше его оставлять таким, каким он отображён при входе в меню.
* Group: группа, к которой будет принадлежать пользователь. Если её не указывать, то она будет совпадать с именем пользователя. Для того, чтобы ваш пользователь мог переключаться на root, необходимо добавить к группе wheel (ни в коем случае не давайте ему эту группу как основную): `pw usermod USERNAME -G wheel`
* Password: пароль пользователя, можно не указывать, при необходимости его можно задать пользователем root с помощью команды passwd имя_пользователя.
* Full name: описание пользователя, никак не используется при работе, нужно только для администратора системы.
* Member groups: дополнительные группы, в которые нужно включить пользователя. Пока можно не заполнять.
* Home directory: домашний каталог пользователя, по сути единственная папка в которой обычный пользователь может делать всё, что ему вздумается, то место, где пользователь может хранить свои документы.
* Login shell: текстовая оболочка, с которой может работать пользователь. По умолчанию это `/bin/sh`. Можно использовать и другие, например `/bin/tcsh` - более продвинутая, чем sh, `/usr/sbin/nologin` - для пользователей, которые не могут непосредственно работать в системе и т.д.

Следующий пункт меню - Console. Здесь мы конфигурируем нашу консоль. Это первый этап русификации:

* Font - необходимо указать IBM 866. Исторически так сложилась, что это наиболее удачная кодировка для вывода на консоль, т.к. кроме символов содержит также элементы псевдографики.
* Keymap - используемая кодировка. Самая удобная на данный момент является Russia KOI8-R.
* Repeat - скорость автоповтора нажатия клавиш. Для меня наиболее удобным является вариант Fast. Несмотря на своё название автоповтор нажатий осуществляется довольно медленно.
* Saver - скринсейвер для текстовой консоли. Выбирайте на свой вкус.
* Screenmap - карта соответствия символов кодировки вывода на консоль и кодировки системы, наиболее логично использовать KOI8-R to IBM 866.
* Ttys - выбираем cons25r.

Time zone. Здесь всё просто, нужно указать часовой пояс в котором вы находитесь. Первое, что нас просят сделать, указать, хотим ли мы использовать всемирное координированное время UTC в аппаратных часах компьютера. Тут стоит немного разобраться. Исторически сложилось, что операционные системы производства Microsoft оперируют местным временем. Это вносит множество неудобств: необходимость перевода стрелок часов на летнее время и обратно, переезде из одного часового пояса в другой. Отсюда, наиболее логичным было бы выбрать UTC в аппаратных часах, тогда перевод стрелок производился бы автоматически просто путём указания нового часового пояса или введения коррекции на 1 час (т.к. время UTC не переводится ни зимой, ни летом). Но не спешите. Если на вашем компьютере есть система семейства Microsoft Windows, то данный выбор усложнит вам жизнь. Выражается это тем, что полноценной поддержки UTC в Windows нет. Возможно заставить часы Windows использовать время в UTC, но в некоторых случаях вы получите неточное время, в частности при выходе компьютера из ждущего или спящего режимов. В данном случае Windows неожиданно решает, что время в аппаратных часах время местное. Если же вы счастливый пользователь *nix систем, логичнее выбрать UTC. Далее выбираем регион, для выбора Екатеринбурга нужно выбрать 5 Asia, далее 37 Russian Federation и далее 5 Moscow+2.

Раздел Media - выбор источника установки. Можно не трогать, если вы не хотите его изменить (например установить что-то не с компакт диска, а с FTP).

Раздел Mouse - настройка интерфейса мыши. Надеюсь с этим разделом вы разберётесь самостоятельно, тем более, что чаще всего можно воспользоваться пунктом Auto.

Раздел Networking - настройка локальной сети. Это очень обширный раздел. Не буду вдаваться в подробности его настройки и укажу самое необходимое:

* Interfaces - настройка существующих сетевых интерфейсов.
* Gateway - включение этого пункта позволит вашему компьютеру передавать пакеты между сетевыми интерфейсами в случае установки нескольких сетевых плат.
* Mail - по умолчанию в системе устанавливается sendmail - не самый безопасный компонент, который к тому же нам вовсе не нужен, поэтому выбираем None.
* Sshd - этот демон позволяет получить доступ к вашему компьютеру по сети (доступ к консоли через SSH клиента, например, putty).

На этом можно закончить установку при помощи утилиты `sysinstall` и перейти к редактированию конфигурационных файлов. Перед тем, как вы приступите к редактированию нужно освоить несколько действий в операционной системе:

* cd - смена каталога. По сути мало отличается от аналогичной команды MS-DOS.
* ls - получение содержимого каталога, некоторый аналог dir, если не вдаваться в подробности параметров командной строки. Подробно параметры команды можно получить набрав man ls.
* vi - мощный консольный текстовый редактор.
* ee - текстовый редактор, на мой взгляд более удобный, чем vi. Попробуйте запустите редактор командой ee и поиграйтесь с его возможностями.

### /etc/rc.conf

Один из самых важных конфигурационных файлов системы. В нём сохраняются многие данные о конфигурации системы, а также параметры запуска демонов.

Приступим к его редактированию:

```bash
cd /etc
ee rc.conf
```

После этого мы видим реактор с открытым файлом `rc.conf`. По сути дела в этот файл записались настройки, которые были заданы нами через утилиту `sysinstall`. Добавим в конфигурацию несколько дополнительных штрихов:

* включим раскладку клавиатуры, аналогичную Windows (я думаю даже заядлые пользователи Linux/BSD встречаются с Windows, да и на клавиатуре в большинстве случаев нанесены символы именно в такой раскладке, поэтому будет удобнее придерживаться её как стандарта). Для этого нужно просто найти строчку `keymap="ru.koi8-r"` и изменить её на `keymap="ru.koi8-r.win"`
* выключим прослушивание демоном `syslogd` сетевого интерфейса. Эта возможность нужна в том случае, если вы желаете, чтобы удалённый сервер складывал свои логи на вашу машину непосредственно. Для выключения этой возможности установим флаги при запуске `syslogd` с помощью строчки `syslogd_flags="-ss"`.
* изменим разрешение текстовой консоли, зададим размер 80х50 символов `allscreens_flags="80x50"`.

После внесения всех изменений мы получим что-то вроде

```ini
###############/etc/rc.conf#################
defaultrouter="172.17.22.254"
font8x14="cp866-8x14"
font8x16="cp866b-8x16"
font8x8="cp866-8x8"
hostname="bsd.fsahome.ru"
ifconfig_sk0="inet 172.17.22.1 netmask 255.255.255.0"
keyrate="fast"
keymap="ru.koi8-r.win"
mousechar_start="3"
moused_enable="YES"
scrnmap="koi8-r2cp866"
sendmail_enable="NONE"
syslogd_flags="-ss"
allscreens_flags="80x50"
sshd_enable="YES"
########################################
```

Если в вашем файле имеются дубликаты параметров, можно смело уничтожать все, кроме последних. Именно последнее значение будет использовано. На заметку, утилита sysinstall никогда не удаляет строки из /etc/rc.conf, а всегда добавляет новые. Так что после использования sysinstall желательно заглянуть в rc.conf и убрать оттуда лишние строки, т.к. в этом случае файл становится более лёгок для понимания. Не возбраняется оставлять комментарии к файле. Комментарии начинаются с символа #. Полезным также может стать группировка параметров по смыслу.

### Локализация консоли.

Множество приложений Linux/BSD изначально поддерживают русский язык. При этом они смотрят локаль пользователя и начинают выдавать сообщения на родном языке пользователя. По умолчанию таким языком является английский язык. Нам же удобнее будет получать сообщения на русском языке. Именно этим мы сейчас и займёмся.

Существует несколько способов локализации консоли. О них вы можете подробнее прочитать в handbook. Я же расскажу о способе, когда все пользователи системы имеют единую локаль.

Для начала нам нужно добавить 2 строки в файл `/etc/csh.login`:

```console
setenv LANG ru_RU.KOI8-R
setenv MM_CHARSET KOI8-R
```

Далее нужно добавить 2 строки в файл `/etc/profile`:

```console
LANG=ru_RU.KOI8-R; export LANG
MM_CHARSET=KOI8-R; export MM_CHARSET
```

**Обращаю ваше внимание на то, что часть строки после символа ; НЕ является комментарием!!!**

## Глава 2. Установка приложений.

Вот мы собственно и добрались до того момента, ради чего всё это затевалось. Операционная система - операционной системой, но нам нужно и работать :-) А для этого нам нужны дополнительные приложения.

Во FreeBSD все приложения имеют, как правило, несколько способов установки:

* Классический способ установки из исходников, когда приложение собирается и устанавливается набором команд:

  ```bash
  ./configure
  make
  make install
  ```

  и т.п. Крайне не рекомендую к использованию, хотя в некоторых редких случаях к нему можно прибегнуть.
* Установка из так называемых портов. Это наиболее прогрессивный способ установки, который к тому же позволяет избежать множества проблем со взаимосвязями приложений. Рекомендую к применению для большинства приложений, размер архива исходных кодов которого не превышает 10-30Мбайт. Для остальных случаев лучше подходит 3 способ.
* Установка через набор приложений /usr/ports/ports-mgmt/portupgrade/. По сути это та же установка из портов, но позволяет облегчить управление установленными приложениями. Советую разобраться с этим способом по подробнее, т.к. он позволяет легко поддерживать систему в актуальном состоянии. Установка приложений производится через команду portinstall. Через команду portupgrade можно обновлять установленные программы. portversion позволяет выявить устаревшие программы.
* Установка из бинарных пакетов - packages. Порты и пакеты связаны между собой. Множество портов имеют файл со списком установочных файлов, благодаря чему можно создать package из порта. Это самый быстрый способ установки приложений, т.к. по сути дела представляет из себя извлечение файлов из архива в заранее определённые папки. Однако у этого способа есть и крупный недостаток - собранное приложение требует конкретные версии пакетов, от которых оно зависит, поэтому рекомендую использовать данный способ установки только для очень громоздких приложений (например, OpenOffice.org, сборка которого может занять больше суток на PIV 2,8ГГц). К слову сказать, дистрибутивные диски FreeBSD как раз содержат набор таких пакетов для установки.
* Специфические методы установки. Применяются в основном для приложений с закрытым исходным кодом. Собственно говоря сюда можно отнести все остальные способы установки, как говорится кто во что горазд.

Надстройкой над системой пакетов является утилита sysinstall. Вновь зайдём в меню Configure вышеуказанной утилиты и обратим внимание на пункт Packages. Это и есть менеджер пакетов, которые хранятся на дисках с дистрибутивом ОС. После выбора этого пункта нам предложат выбрать источник установки.

Дальнейшее меню предложит нам выбрать или пакеты из какого-то раздела системы портов, либо все имеющиеся пакеты в дистрибутиве (All). Выбор нужных приложений не составляет труда, учитывая то, что  при выборе пакета выбираются все зависимые от него пакеты. Надеюсь вы тут быстро освоитесь.

Теперь посмотрим, как можно устанавливать пакеты вручную. Собственно ничего в этом сложного нет, достаточно выполнить команду

```bash
pkg_add назание_пакета.tbz
```

После её выполнения произойдёт установка пакета, либо будет сообщено какие пакеты ещё не установлены, но требуются для работы приложения. Если эти пакеты уже имеются в той же самой папке, что они будут автоматически установлены. Установку пакета можно форсировать с помощью опции -f:

```bash
pkg_add -f название_пакета.tbz
```

но это может оказаться эффективным только в том случае, если требуемая версия пакета имеет номер отличный от требуемого. Установку пакетов таким образом вы выполняете на свой страх и риск.

Также интересной опцией установки пакетов может являться вариант:

```bash
pkg_add -r название_пакета
```

В этом случае будет произведён поиск пакета с указанным названием на ftp-сервере проекта FreeBSD, если заданный пакет будет обнаружен, то он будет скачан и установлен. Однако в этом случае повторная установка пакета уже не будет возможно, т.к. сам пакет после установки будет уничтожен. Так же будут скачаны и установлены все пакеты, от которых имеются зависомость.

Самый удобный способ установки приложений через утилиту portugrade. portupgrade это набор утилит, облегчающий установку и обновление пакетов из коллекции портов. Сама коллекция расположена по адресу /usr/ports. Все приложения разделены на категории, такие как: аудио, мультимедиа, графика, сетевые компоненты, WWW-сервера и клиенты и т.д. Коллекция портов напоминает собой живой организм, т.к. поддерживается большим числом людей. Порты обновляются после выхода новых версий приложений, а также при обнаружении каких-либо недоработок или неудобств в использовании установленных приложений. В отличие от других систем, вам не нужно бродить в интернете в поиске нужной программы, достаточно ознакомиться в содержимым коллекции портов. Большинство популярных приложений имеют уже готовые порты.

Установка приложений из портов не простое занятие, а очень простое!!! Достаточно набрать команду:

```bash
make install
```

находясь в папке с интересующим приложением. Система проверить наличие необходимых исходных кодов в папке `/usr/ports/distfiles` и при их отсутствии загрузит их из источников распространения приложения. Если для работы приложения требуются какие-то дополнительные компоненты, то они будут установлены через соответствующие порты. Из этого достоинства вытекает "недостаток", ведь если у вас имеется доступ в интернет с довольно дорогой стоимостью мегабайта, нужно очень осторожно устанавливать приложения. Так например при установке веб-сервера с поддержкой PHP и MySQL может понадобится загрузка исходных кодов кроме Apache ещё и PHP и MySQL, что может составить довольно кругленькую сумму.

Если вы используете portupgrade, то установить приложение будет ещё проще. Достаточно дать команду

```bash
portinstall port_name
```

Либо

```bash
portupgrade -N port_name
```

где `port_name` - имя необходимого порта и система сделает всё необходимое для установки приложения. Если запросу соответствуют несколько приложений, система спросит, какие именно вы хотите установить.

Отдельно рассмотрим вариант, если на вашем компьютере нет доступа в интернет, тогда попытка загрузки необходимых файлов завершиться с ошибкой. В этом случае можно скачать необходимые файлы отдельно и поместить их в папку `/usr/ports/distfiles` (либо в папку внутри этой папки). Что скачать и куда поместить можно разобраться внимательно ознакомившись с сообщениями об ошибках.

Если вы работаете через прокси, то необходимо его указать. Поскольку загрузка происходит с помощью команды fetch, то следует изучить man fetch. Из описания мы узнаем, что нужно определить переменные окружения HTTP_PROXY и FTP_PROXY (к слову сказать, при просмотре man fetch мы их не увидим, зато внутри описания есть ссылка на fetch(3), т.е. мы можем получить дополнительные подробности выполнив команду man 3 fetch). Сделать это можно отредактировав файл `.cshrc` в домашнем каталоге пользователя, от которого производится установка (обычно это root, т.е. нас интересует файл `/root/.cshrc`):

```bash
cd ~
ee .cshrc
```

далее добавляем строку следующего содержания

```console
set HTTP_PROXY 192.168.1.1:3128
```

или

```console
set FTP_PROXY 192.168.1.1:3129
```

где 192.168.1.1:3128 - адрес и порт HTTP-прокси, 192.168.1.1:3129 - адрес и порт FTP-прокси.

Если адрес FTP-прокси не указан, то при наличии записи HTTP-прокси, загрузка будет производиться через него, как имеющего поддержку FTP.

Для упрощения исследования системы я бы посоветовал установить следующий порт: `/usr/ports/misc/mc/` - файловый менеджер в стиле Norton Commander - Midnight Commander. Позволит вам наглядно познакомится со структурой каталогов вашей системы. Однако его использование значительно урезает возможности командной строки. С набором опыта вполне возможно, что вам даже покажется неудобным использовать mc!

## Глава 3. Запуск X-сервера.

### 3.1. Настройка X-сервера.

**Данный раздел требует доработки. Уже в текущих версиях Xorg значительно улучшен механизм автоматического определения устройств с использованием HAL. Если вы решили воспользоваться данной информацией по настройке Xorg, возможно вам необходимо будет добавить в `xorg.conf` в секцию `ServerLayout` строку**

```console
Option "AutoAddDevices" "off"
```

**В будущих версиях Xorg также будут вноситься значительные изменения, в том числе отказ от HAL и переход на другие методы определения подключенных устройств.**

Если вы следовали всем моим инструкциям, то X-сервер на вашем компьютере уже установлен. Если его нет, то запускаем sysinstall и добавляем его из Distributions.

Для создания базовой конфигурации, которую мы будем в дальнейшем редактировать, воспользуемся утилитой `xorgconfig`.

После запуска на экране можно прочитать краткое описание утилиты, также то, что прервать её работу без сохрания можно с помощью кнопок CTRL+C. Ознакомившись с описанием переходим к первому этапу настройки с помощи клавиши Enter. Кстати говоря, большинство настроек, которые мы сейчас производим мы будем исправлять вручную, так на некоторых этапах можно просто указывать любые варианты ответов.

* На этом этапе нам предлагают выбрать тип нашей мыши. В большинстве случаев достаточно выбрать пункт 1 - Auto, если конечно вы не являетесь обладателем какого-нибудь антиквариата или эксклюзивной модели :-)
* Теперь нам задают вопрос нужно ли эмулировать третью кнопку мыши. Собственно говоря можно ответить и так и так, всё равно мы в будущем будем редактировать конфигурацию вручную. Просто нажмём Enter.
* Далее нас просят указать файл устройства который связан с нашей мышь. Пока мы просто нажмём Enter.
* На следующем этапе нам предлагают выбрать тип клавиатуры. Типичные варианты - Generic. Обладателем различного рода клавиатур с мультимедийным клавишами можно попытаться найти свою, однако тоже можно обойтись стандартным вариантом. Мне очень понравилось, что свою мультимедийную клавиатуру Genius Comfy KB-21e-Scroll нашёл без проблем.
* Далее предлагают выбрать страну. Выбираем конечно же Russia.
* Вопрос о вариантах раскладки мы пока пропустим, просто нажмём Enter.
* На вопрос о дополнительных XKB опциях также ответим Enter'ом. Дальнейшие этапы будут относится к настройке видео. Советую найти документацию на ваш монитор и посмотреть те видеорежимы в каких он может работать.
* Первым вопрос о том, какую частоту строчной развёртки имеет монитор (horizontal sync). Основным ориентиром для нас могут стать комментарии к режимам. Если вы нашли эти парамеры в документации, то можете указать вручную указать диапазон частот.
* Вопрос о частоте кадровой развёртки (vertical sync). Если на глаз заметить влияние частоты строчной развёртки очень сложно, то от этого параметра очень многое зависит. Надеюсь вы осмыслено выставляли эту частоту в Windows, поэтому стоит здесь задать именно те самые значения частоты, что вы указывали ранее в Windows. Если вы столкнулись с этим параметром впервые, то первый совет - не устанавливайте величину менее 75 Гц для мониторов с электронно лучевой трубкой, т.к. в этом случае будет очень заметное на глаз мерцание. Лично я сразу замечаю усталость глаз после нескольких минут работы при частоте 70 Гц. Советую частоту выбрать максимально большой, но при этом такой, чтобы ваш монитор её поддерживал. Для очень старых мониторов превышение частоты выше нормы может привести к физическому повреждению, более или менее современные мониторы оснащены защитой от таких экстремальных нагрузок и просто засыпают или выводят на экран предупреждающую табличку. Для TFT мониторов величина этого значения большой роли не играет. Лучше всего будет найти рекомендуемую частоту в документации к монитору и выставить именно её, т.к. отклонение от неё может повысить размытость изображения.
* Далее вас просят ввести название монитора. Можно указать имя производителя или вообще любую информацию. Она нужна только для идентификации монитора из нескольких. Думаю у вас только один монитор :-) Можно просто нажать Enter.
* Следующим вопросом система интересуется хотим ли мы взглянуть на список видеокарт. Соглашаемся введя y. В огромном списке видеокарт нас интересуют в основном две страницы, хотя вы можете попытать счастье и найти свою видеокарту в "бесконечном" списке. Если вы обладатель карт от Nvidia, то считайте, что вам повезло и вы можете скачать нужный драйвер имеющий более широкие возможности, чем стандартный под номером 18 (идентификатор "nv"). Если вы не планируете широко использоваться возможности видеокарты, то вам вполне подойдёт драйвер из стандартного набора. В некоторых случаях могут возникнуть трудности с поиском нужного драйвера для вашей видеокарты, например, у меня были сложности с поиском драйвера для видеокарты ноутбука. Тут может помочь способ «прямого тыка» или изучение форумов в интернете с нужной тематикой. Самыми беспроблемными для меня стали видеокарты: Nvidia, ATI, интегрированные видеокарты на базе чипсета Intel (различные модификации от i810 и выше). Если вы совсем не можете определиться с видеокартой, попробуйте варианты 1 и 2, однако в большинстве вы только сможете запустить X-сервер, но полноценную картинку получить не получится.
* Вопрос об объёме оперативной памяти видеокарты, думаю, не поставить вас в тупик, раз уж вы решились на такой шаг, как установка FreeBSD :-)
* Следующий вопрос - идентификатор видеокарты, можно просто нажать Enter.
* Далее нужно выбрать видеорежимы для видеокарты. Изначально уже выбраны такие разрешения и грубина цвета:

  ```console
  "1280x1024" "1024x768" "800x600" "640x480" for 8-bit
  "1280x1024" "1024x768" "800x600" "640x480" for 16-bit
  "1280x1024" "1024x768" "800x600" "640x480" for 24-bit
  ```

  Если вас это устраивает, то выбираем вариант 4, иначе правим разрешения для интересующей грубины цвета.
* Следующий вопрос - используемая грубина цвета по умолчанию. Лучше всего выбрать вариант 24, но если вы собираетесь использовать драйвер видеокарты VGA или VESA этот видеорежим окажется ему не по силам.
* И последний вопрос - хотим ли мы сохранить настройки в файл `xorg.conf`. Нажимаем Enter. Файл по умолчанию сохраняется в папку `/etc/X11`, поэтому вы должны выполнять конфигурацию от имени root. Если вы выполняли настройки от имени рядового пользователя, можете  указать своё размещение файла, например, `~/xorg.conf`, чтобы создать файл в вашей домашней папке. В дальнейшем вы просто можете перенести его в папку `/etc/X11`.

На этом автоматизированную процедуру мы закончили. Все дальнейшие настройки производим с помощью текстового редактора.

Итак, приступаем к редактированию:

```bash
ee /etc/X11/xorg.conf
```

Первым делом внимательно ознакомимся в существующими секциями файла:

Раскладка сервера:

```console
Section "ServerLayout"
    Identifier     "Simple Layout"            # Имя раскладки
    Screen         "Screen 0" 0 0             # Используемый Screen
    InputDevice    "Mouse1" "CorePointer"     # Используемая мышь
    InputDevice    "Keyboard1" "CoreKeyboard" # Используемая клавиатура.
#   Option         "AutoAddDevices" "off"     # запретить автоматическое определение устройств, укажите, если используете Xorg 7.4 и старше.
EndSection
```

Описание указанных значений в следующих секциях.

Описание используемых каталогов:

```console
Section "Files"
    RgbPath         "/usr/X11R6/lib/X11/rgb"
    ModulePath      "/usr/X11R6/lib/modules"
    FontPath        "/usr/X11R6/lib/X11/fonts/misc"
    FontPath        "/usr/X11R6/lib/X11/fonts/TTF"
    FontPath        "/usr/X11R6/lib/X11/fonts/Type1"
    FontPath        "/usr/X11R6/lib/X11/fonts/75dpi"
    FontPath        "/usr/X11R6/lib/X11/fonts/100dpi"
    FontPath        "/usr/X11R6/lib/X11/fonts/local"
    FontPath        "/usr/X11R6/lib/X11/fonts/webfonts"
EndSection
```

Тут ничего хитрого нет, все значения указаны автоматически, за исключением последней строчки FontPath. В ней я указал каталог расположения кириллических шрифтов. О шрифтах я расскажу в дальнейшем.

Список используемых модулей:

```console
Section "Module"
    Load           "dbe"        # Double buffer extension
    SubSection     "extmod"
        Option         "omit xfree86-dga"   # don't initialise the DGA extension
    EndSubSection
    Load           "glx"
    Load           "record"
    Load           "xtrap"
    Load           "freetype"
    Load           "type1"
EndSection
```

Изменений я в списке не делал.

Настройки клавиатуры:

```console
Section "InputDevice"
    Identifier     "Keyboard1"
    Driver         "kbd"
    Option         "AutoRepeat" "500 30"
    Option         "XkbRules" "xorg"
    Option         "XkbModel" "geniuscomfy2"
    Option         "XkbLayout" "us,ru"
    Option         "XkbVariant" "basic,winkeys"
    Option         "XkbOptions" "grp:ctrl_shift_toggle,numpad:microsoft"
EndSection
```

где

* `XkbModel` - тип клавиатуры, используется клавиатура Genius KB-21e Scroll.
* `XkbLayout` - используемые раскладки клавиатуры: латиницы и кириллица.
* `XkbVariant` - вариант раскладки клавиатуры.
* `XkbOptions` - установка в качестве переключателя раскладки сочетания кнопок CTRL+SHIFT, а также расположения знаков препинания на клавиатуре аналогично Microsoft Windows (в частности это касается знаков на цифровых клавишах).

В этой секции пришлось внести некоторые изменения, которые описаны в комментариях.

Настройки мыши:

```console
Section "InputDevice"
    Identifier     "Mouse1"
    Driver         "mouse"
    Option         "Protocol" "Auto"        # Auto detect
    Option         "Device" "/dev/sysmouse"
    Option         "ZAxisMapping" "4 5 6 7" # включение поддержки колеса мыши
EndSection
```

Здесь, в основном, интересна только последняя строчка. Остальные строчки сформированы утилитой `xorgconfig`.

Указание типа монитора:

```console
Section "Monitor"
    Identifier     "Benq FP931"
    VendorName     "Benq"
    ModelName      "Benq FP931"
    DisplaySize     1280    1024
    HorizSync       30.0 - 64.0
    VertRefresh     75.0
EndSection
```

Определение типа видеоадаптера:

```console
Section "Device"
    Identifier     "NVIDIA GeForce"
    Driver         "nvidia"
    VendorName     "NVidia"
EndSection
```

В этом разделе интересен пункт Driver, который указывает на используемый драйвер. В моём случае используется драйвер с сайта www.nvidia.com, установленный из портов `/usr/ports/x11/nvidia-driver`. Список имеющихся драйверов можно найти в каталоге `/usr/X116/lib/modules/drivers`.

Определение видеорежимов:

```console
Section "Screen"
    Identifier     "Screen 0"
    Device         "NVIDIA GeForce"
    Monitor        "Benq FP931"
    DefaultDepth    24
    Option         "ConnectedMonitor" "CRT,TV"
    Option         "TVStandard" "NTSC-M"
    Option         "TwinView" "yes"
    Option         "TwinViewOrientation" "Clone"
    Option         "MetaModes" "1280x1024,1024x768@1280x1024; 1024x768,1024x768; 800x600,800x600; 640x480,640x480"
    Option         "HorizSync" "CRT-0: 30.0-85.0; TV-0: 20.0-50.0"
    Option         "VertRefresh" "CRT-0: 75.0; TV-0: 45.0-100.0"
    SubSection     "Display"
        Viewport    0 0
        Depth       8
    EndSubSection
    SubSection     "Display"
        Viewport    0 0
        Depth       16
    EndSubSection
    SubSection     "Display"
        Viewport    0 0
        Depth       24
    EndSubSection
EndSection
```

В данном случае кроме стандартных настроек добавлены также опции для вывода клона изображения на телевизор. При этом в режиме 1280x1024 используется панорамирование на телевизоре до размера 1024х768 (показывается только часть картинки, при перемещении курсора рабочий стол смещается в нужном направлении).

### 3.2. Первый запуск X-сервера.

Вот мы и подошли к моменту запуска Xorg, который будет являться базовой частью для вашей графической оболочки. Запускаем X-сервер от имени обычного пользователя:

```bash
startx
```

После этого на экране должно появится изображение с 3 окнами. Обратите внимание на разрешение и кадровую частоту (изображение не должно мерцать). Если изображение мерцает или разрешение не то, что требуется, внимательно изучаем `/etc/X11/xorg.conf` и пробуем изменить видеорежимы.

Первая проблема с которой вы можете столкнуться - необходимо выйти из xorg. Сделать это можно просто набрав exit во всех открытых окнах. Если это у вас не получается, можно попробовать «по наглому» заглушить X-сервер. Для этого переключаемся сочетанием кнопок CTRL+ALT+Fn на консоль, откуда производился запуск xorg и нажимаем CTRL+C.

Если изображение при запуске xorg не появилось, а высветилась ошибка, начинаем разбираться в причинах:

* Самая банальная ошибка - ошибка в настройках xorg.conf. Как правило X-сервер сообщает о номере строки, которая вызывает подозрение.
* X-сервер сообщает, что он не поддерживает заданную губину цвета. Скорее всего вы неправильно указали драйвер или использовали драйвер видеокарты VGA или VESA, которые не поддерживают современные видеорежимы. В последнем случае рекомендую найти драйвер именно под вашу видеокарту.
* X-сервер сообщает, что не может запуститься ввиду того, что не может задать Screen. В этом случае скорее всего неправильно задав драйвер видеокарты.

## Глава 4. Работа в графической оболочке.

Вот, собственно говоря, мы и подошли к самому интересному для нас - запуску графической оболочки, которая позволит нам использовать компьютер для работы. Все дальнейшие действия лучше выполнять от имени обычного пользователя, а не root (графическая оболочка имеет очень сложную структуру и множество различных компонентов, поэтому может стать объектом атаки по сети).

Самый простой способ запустить графическую оболочку - выполнить команду startkde (для KDE) или gnome-session (для Gnome) после запуска команды startx, однако в этом случае мы получаем довольно "кривое" отображение. Лучшим способом будет указать X-серверу загружать нужную нам графическую оболочку при запуске. Сделать это можно создав файл .xinitrc в нашем домашнем каталоге и указать в нём какие команды необходимо выполнять при запуске xorg:

```bash
cd ~
touch .xinitrc
ee .xinitrc
```

В открывшемся окне редактора пишем следующее:

```console
gnome-session
```

После этого выходим из редактора с сохранением. Теперь можем вновь дать команду startx. После её запуска на экране должна появиться заставка Gnome. На этом установку системы можно считать законченной :-) Теперь нужно только установить необходимые программы и уже можно работать.

### 4.1. Включаем звук.

Первое, что вы могли заметить при запуске - табличку с сообщением о невозможности запустить звуковую систему (или просто отсутствие каких-либо звуков). А какой современный компьютер без музыки скажете вы. Поэтому мы сейчас займёмся запуском звука. Собственно звук не привязан к графической оболочке, скорее графическая оболочка использует звуковую систему для уведобления пользователя о событиях.

Благодаря стараниям разработчиков системы мы имеем огромные набор драйверов для звуковых плат. Осталось разобраться какой драйвер нам нужен.

Самый простой способ задействовать вашу звуковую карту - подключить модуль ядра, умеющий работать с вашей звуковой платой. Найти его несложно. Перед началом настройки выгрузим графическую оболочку. Модули ядра расположены в папке /boot/kernel. Файлы звуковых драйверов имеют название, начинающееся с `snd_`.

```bash
cd /boot/kernel
ls snd_*
```

Таким образом мы получили список имеющихся драйверов. Самым простой способ найти какой же необходим нам - загрузить все модули. Делается это загрукой модуля snd_sound.ko:

```bash
kldload snd_driver
```

После этого действия на первой текстовой консоли должны появиться сообщения о найденных устройствах. Если этого не произошло, сожалею, поддержки вашей звуковой платы в системе нет. Нужно искать сторонние драйвера. Однако мне ещё не встречались такие случаи.

Итак, драйвера загружены, а какой же из них наш. Выполняем команду:

```bash
cat /dev/sndstat
```

В ответ нам выдаётся сообщение о задействованных звуковых модулях. Внимательно его изучаем и находим нужного нам модуля. После этого выполняем перезагрузку и пробуем загрузить этот модуль с помощью команды

```bash
kldload snd_hda
```

где snd_hda заменяем на имя нужного нам модуля. Если после загрузки мы увидели те же самые сообщения, что и в первом случае, то модуль ядра успешно найден. Если сообщения не появились, то возвращаемся к началу и внимательней изучаем содержание sndstat.

Для того, чтобы нужный нам модуль загружался автоматически, необходимо отредактировать файл `/boot/loader.conf`:

```bash
ee /boot/loader.conf
```

Добавляем туда строчку следующего содержания:

```console
snd_hda_load="YES"
```

где snd_hda заменяем названием нужного вам модуля. После этого перезагружаемся:

```bash
reboot
```

и внимательно изучаем сообщения при загрузке системы. В них мы должны найти сообщения об успешной активации вашей звуковой карты.

Ещё одним способом является включение необходимого модуля непосредственно в ядро системы. Однако это требует пересборки ядра, чем мы займёмся немного позднее.

Если всё загружено успешно, заходим в систему под непривилегированным пользователем и запускаем графичекую оболочку:

```bash
startx
```

Система должна нас приветствовать радостной мелодией!

### 4.2. Установка кириллических шрифтов.

В составе системы имеются различные шрифты, то при отображении сайтов, которые разрабатывались в Windows мы теряем внешний вид. Раньше я предпочитал устанавливать набор ttf шрифтов из Windows, поэтому сначала рассмотрим этот вариант.

Первым делом нужно скопировать шрифты *.ttf из папки Windows/Fonts в папку, например,  /usr/X11R6/lib/X11/fonts/win-ttf. Далее необходимо проделать несколько действий:

```bash
cd /usr/X11R6/lib/X11/fonts/win-ttf
mkfontscale
mkfontdir
```

после этих действий в папке должны появиться два файла `font.dir` и `font.scale`.

Последнее действие:

```bash
fc-cache /usr/X11R6/lib/X11/fonts/win-ttf
```

Запускаем графическую оболочку и пользуемся шрифтами.

Кроме этого, наборы шрифтов можно найти в портах `/usr/ports/x11-fonts`. Сейчас я использую порт `/usr/ports/x11-fonts/webfonts`.

### 4.3. Слушаем музыку.

Для прослушивания музыки существует масса проигрыватель. Раньше я был любителем Winamp, поэтому на первых порах выбрал проигрыватель XMMS. Найти проигрыватель можно в портах: `/usr/ports/multimedia/xmms`. Однако данный порт не совсем корректно работает с кириллицей. Решить некоторое количество проблем с кодировками можно установив XMMS посредством порта `/usr/ports/russian/xmms`. В этом случае мы получаем тот же самый проигрыватель, но с поддержкой перекодировки тегов и имён файлов. Хотя мне так и не удалось заставить XMMS корректно сортировать песни в плейлисте.

В настоящее время я использую связку musicpd (демон, работащий в фоне и проигрывающий музыку) и gmpc (графическая оболочка для управления демоном).

### 4.4. Записываем диски CD/DVD.

Редкий современный компьютер обходится без пишущего привода. Поскольку мы делаем рабочую станцию, то хотелось бы научиться также писать CD и DVD диски.

Наверняка вы слышали о таких программах, как burncd и cdrecord - консольные утилиты для записи CD. Не будем недооценивать их мощи, но наверняка вам хотелось бы иметь более удобный инструмент для записи. Таким инструментом по праву может стать программа k3b (или brasero в составе Gnome): `/usr/ports/sysutils/k3b`. Собственно говоря эта программы сами не умеет писать диски, а просто управляет утилитами для записи. Отсюда вытекает необходимость в настройке этой утилиты. Кроме того, если вы собираетесь записывать DVD диски, то необходимо установить дополнительные утилиты для работы с DVD. О том, что нужно добавить, вам расскажет сам k3b.

Как известно, утилита умеет работать только со SCSI устройствами, поэтому первое что мы должны сделать - подгрузить модуль ядра atapicam для обеспечения эмуляции SCSI устройства для нашего CD/DVD привода. Выполняем команду:

```bash
kldload atapicam
```

Первая консоль должна отреагировать положительно и объявить о появлении нового устройства cd0, также должен появиться файл устройства `/dev/cd0`.

Первый подводный камень с которым мне пришлось встретиться - зависание системы после загрузки модуля ядра. Как выяснилось позже  виновником был SATA контроллер на материнской плате. Поскольку у меня на компьютере нет SATA жёстких дисков, я попросту его отключил. Если у вас возникла аналогичная проблема и вам нужен SATA контроллер, можно попробовать поиграться с порядком контроллеров в системе. После этого, к сожалению, придётся заново настраивать файл `/etc/fstab`, а чтобы его отредактировать, научиться пользоваться утилитой fixit с дистрибутивного диска FreeBSD.

Если загрузка atapicam прошла успешно, не забываем поместить его в автозагрузку:

```bash
ee /boot/loader.conf
```

Добавляем в него строку

```ini
atapicam_load="YES"
```

Не возбраняется также добавить atapicam непосредственно в ядро системы при пересборке ядра, тогда загружать его через locader.conf не нужно.

Далее нам необходимо проверить, нашла ли утилита cdrecord наш привод/приводы. Выполняем команду:

```bash
cdrecord -scanbus
```

В ответ мы должны получить примерно следующее:

```console
Cdrecord-Clone 2.01 (i386-unknown-freebsd6.1) Copyright (C) 1995-2004 JЖrg Schilling
Using libscg version 'schily-0.8'.
scsibus1:
        1,0,0   100) '_NEC    ' 'DVD_RW ND-4571A ' '1-02' Removable CD-ROM
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) *
        1,6,0   106) *
        1,7,0   107) *
```

Т.е. в моём случае cdrecord нашла привод NEC ND-4571A.

На радостях запускаем k3b, но обнаруживаем, что она отказывается видеть наш привод. Почему? Просто все предыдущие команды мы выполняли от пользователя root, а k3b мы запускаем от имени обычного пользователя. Можете попробовать запустить k3b от имени root и убедиться, что программа определяет привод, но нам было бы удобнее и безопаснее работать от имени обычного пользователя. Решением этой проблемы сейчас и займёмся. Самый простой способ выполнить следующую последовательность команд:

```bash
cd /dev
chmod 0666 acd0 cd0 xpt0 pass0
```

Устройства xpt0 и pass0 также необходимы для выполнения записи на диск. После выполнения команд можно запустить k3b и убедиться, что привод определяется. Однако после перезагрузки необходимо будет заново выполнять эту последовательность команд. Чтобы избавиться от этого, воспользуемся файлом /etc/devfs.conf. Через этот файл можно задавать владельца и права доступа на файлы устройств при загрузке системы.

Начиная работать с правами сделаем также так, чтобы права на запись диском имели только строго определённые пользователи. Как вы могли заметить, все используемые устройства принадлежат к группе operator. Для разрешения записи мы просто добавим нужного пользователя к этой группе при помощи команды:

```bash
pw usermod USERNAME -G operator,wheel
```

Обратите внимание, что мы в данном случае также присвоили пользователю группу wheel, благодаря чему дали ему возможность выполнять команду su root, если этого не нужно, то группу wheel можно не указывать. Также обратите внимание на регистр буквы G перед списком групп. Ни в коем случае не используйте g, т.к. она предназначена для задания основной группы пользователя (а её название как правило совпадает с именем пользователя и эта группа может быть только единственной группой).

Итак, зададим необходимые права доступа на файлы:

```bash
ee /etc/devfs.conf
```

добавим в него следующие строки

```console
perm    acd0    0660
perm    cd0     0660
perm    xpt0    0660
perm    pass0   0660
```

Таким образом мы разрешим доступ к устройствам для root и группы operator.
Можно также добавить следующие строки

```console
own     acd0    root:operator
own     cd0     root:operator
own     xpt0    root:operator
own     pass0    root:operator
```

Однако во FreeBSD 6.1 данные файлы и так имеют вышеуказанных владельца и группу. Однако кто знает что будет в следующих версиях, поэтому эти строки лишними не будут.

На этом можно заканчивать. Теперь достаточно перезагрузить систему и проверить, что вы можете успешно записывать CD и DVD диски.

После нескольких экспериментов с системой я вдруг обнаружил, что k3b потерял мой DVD привод. Решение оказалось допольно простым, просто у меня появилось ещё одно устройство pass1, которое и нужно было для нормальной работы DVD привода.

## 5. Поддержание системы в актуальном состоянии.

Немаловажно поддерживать приложения системы в актуальном состоянии. Всё, что для этого нужно уже придумали за нас. Начнём с того, что необходимо установить порт /usr/ports/ports-mgmt/portupgrade/. Это целый программный комплекс, призванные упростить управление установленными программными пакетами.

Прежде чем заняться обновлением ПО необходимо обновить базу портов. Выполнить это можно с помощью стандртной утилиты csup. Стоит заметить, что в настоящий момент начат процесс перехода на subversion, поэтому в будущем процесс обновления портов может измениться.

Для обновления дерева портов нам необходим файл конфигурации. Самый простой способ получить его - воспользоваться уже готовым в каталоге с примерами: /usr/share/examples/cvsup/ports-supfile. Скопируйте его в удобное для вас место. Перед обновлением портов нужно добавить один штрих - указать сервер, с которого будет производиться обновление.

```console
*default host=CHANGE_THIS.FreeBSD.org
```

Замените CHANGE_THIS на наиболее подходящее для вас зеркало. Для России во многих случаях оптимальным будет использование зеркала Яндекса: cvsup7.ru.FreeBSD.org. Посмотреть полный список зеркал можно по адресу [ссылке](http://www.freebsd.org/doc/ru_RU.KOI8-R/books/handbook/cvsup.html#CVSUP-MIRRORS). Для обновления портов данного изменения ports-supfile достаточно.

Можно приступить к обновлению дерева портов:

```bash
csup -L 2 ports-supfile
```

Ключ -L 2 в команде просто указывает на объём выводимой информации во время обновления. Процесс обновления достаточно продолжительный. Так он зависит от скорости вашего интернет-соединения.

**Обращаю ваше внимание на то, что используется команда csup, а не cvsup, о которой вы можете прочитать в документации. csup - это аналог cvsup без gui-интерфейса написанный на языке C++. Также csup  включен в стандартную поставку системы начиная с 6.2 версии. Если вы желаете, то можете использовать cvsup. В таком случае для отключения gui необходимо добавить ключ -g при выполенении обновления.**

По окончании процесса обновления можно заняться обновлением. Для начала создадим необходимые базы данных `/usr/ports/INDEX-*` и `/usr/ports/INDEX-*.db`. Первый файл - это стандартная база коллекции портов, второй - бинарная база, используемая комплексом portupgrade. Итак, выполняем:

```bash
portsdb -Uu
```

Ключ U отвечает за базу INDEX, u - INDEX.db. Процесс создания базы довольно продолжительный, так что запаситесь терпением. После того, как база создана, можно просмотреть список устаревших пакетов.

```bash
portversion
```

В данном случае вы получите полный список всех установленных портов. Символами меньше, больше или равно отмечены соотвественно устаревшие, актуальные и более новые пакеты, чем в вашей текущей базе (скорее всего ваша база данных портов устарела и её надо переформировать, предварительно обновив порты).

```bash
portversion -l "&lt;"
```

Таким образом можно просмотреть список только устаревших установленных портов.

**Сравнение версий производится не по базе /var/db/pkg, а /var/db/pkgdb.db. Эта база автоматически обновляется при использовании portugrade. Однако в некоторых случаях может потребоваться скорректировать эту базу, для чего можно использовать утилиту pkgdb с ключами -F (интерактивный режим) или -fu (автоматический режим).**

Вооружившись списком устаревших портов можем обновить из по одному

```bash
portupgrade libGL
```

Как вы понимаете, занятие это утомительное. Поэтому можно воспользоваться ключём -a, который заставит portupgrade обновить все устаревшие порты. Кроме этого, возможно понадобятся ещё две опции, заставляющие рекурсивно обновлять пакеты -r (обновлять также все порты, которые зависят от обновляемых) и -R (обновление всех портов, от которых зависят обновляемые). Таким образом даём команду

```bash
portupgrade -arR
```

и ожидаем завершение установки. Процесс обновления зависит от количества обновляемых портов и от производительности компьютера. Иногда может потребоваться очень много времени (при большом числе пакетов) Кроме того, во время обновления из сети скачиваются все необходимые исходные коды приложений. Чтобы этого не происходило, можете перед процессом обновления скачать все необходимые файлы, воспользовавшись командой

```bash
portupgrade -arRF
```

Во время обновления портов периодически обращайте внимание на консоль. Некоторые порты выводят интерактивное меню и требуют выбрать определённые опции. Пока вы этого не сделаете, процесс сборки портов останавливается.

**Во время сборки портов возможны различного рода ошибки. Большинство известных проблем описано в файле `/usr/ports/UPDATING`. Не стоит пренебрегать изучением этого файлы перед обновлением системы.**

## 6. Обновление базовой системы.

### 6.1. Загрузка свежего исходного кода базовой системы.

В предыдущем разделе я рассматривал обновление установленных программных пакетов в системе. Однако таким образом нельзя обновить непосредственно базовую систему. Сделать это ещё проще, чем обновлять установленные порты.

Также, как и с приложениями, возможно обновление базовой системы из исходных кодов или готовых бинарных сборок. Рассмотрим первый вариант, т.к. он позволит нам создать своё, более оптимальное ядро.

Для получения актуальной копии исходных кодов системы воспользуемся уже знакомой нам командой csup. Как вы понимаете, нам снова необходим файл конфигурации, который будет описывать откуда скачивать исходный код и куда его помещать на компьютере.

В уже знакомом нам каталоге находим готовый шаблон `/usr/share/examples/cvsup/standard-supfile`. Скопируйте его в удобное для вас место. Также внесём в файл несколько корректив. Во-первых, уже знакомый нам

```console
*default host=CHANGE_THIS.FreeBSD.org
```

Во-вторых, обратим внимание на ещё одну строку

```console
*default release=cvs tag=RELENG_7
```

В ней указывается какую версию исходных кодов скачивать. В данном случае мы скачиваем версию 7-STABLE. Если вы желаете получить, например 6.4-STABLE, то нужно указать RELENG_6_4 и т.д.

Обновим исходные коды системы:

```bash
csup -L 2 standard-supfile
```

Визуально этот процесс напоминает обновление коллекции портов.

После обновления исходных кодов системы не торопитесь сразу приступать к обновлению. Внимательно изучите содержимое файла /usr/src/UPDATING. Он содержит важные замечания по поводу изменений в исходных кодах и методы решения проблем при обновлении.

### 6.2. Создание собственной конфигурации ядра.

**Первый раз можно пропустить данную стадию, т.к. несмотря на то, что можно более оптимально настроить ядро системы, возможно возникновение различных побочных эффектов.**

Процесс настройки и сборки ядра хорошо [описан в документации](https://docs.freebsd.org/ru/books/handbook/kernelconfig/).
