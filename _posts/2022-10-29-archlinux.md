---
layout: post
title: Установка Archlinux
date: 2022-10-29 02:01:00 +0700
tags: [Archlinux, btrfs, EFI]
excerpt: Ради интереса решил поставить Archlinux на btrfs на компьютер с EFI
---

Давно смотрю в сторону Archlinux. Даже пробовал использовать его вместо Ubuntu. Но что-то пошло не так, и я перешёл на Gentoo. В Gentoo тоже что-то пошло не так, но я разобрался и правильно поставил драйвер на видеокарту. Однако решил уже не возвращаться в Archlinux. Спустя много лет решил попробовать хотя бы установить систему на виртуальную машину.

Небольшое замечание. Установку системы можно выполнить с помощью утилиты `archinstall`. Ниже описан ручной способ установки без использования этой утилиты и с минимально возможным количеством пакетов.

При привычке решил воспользоваться [мануалом на сайте проекта](https://wiki.archlinux.org/title/Installation_guide_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)). Всегда так делал в Gentoo. Однако во время установки возникли некоторые проблемы, поэтому решил записать процесс установки.

Установка начинается с разметки диска. Для этого существует масса утилит, которые перечислены в мануале. Я выбрал cgdisk:

```bash
cgdisk /dev/sda
```

После запуска на диске необходимо создать разделы, как минимум:

1. EFI раздел: тип EF00;
2. root раздел: тип 8300 (по умолчанию).

Первый нужен для успешной загрузки через EFI. Кроме этого, в нём будет расположен Grub и ядро операционной системы. Вполне достаточно размера 512 МБ (в cgdisk укажите `512M`), что позволит хранить несколько ядер и не страдать от нехватки места на разделе. Во втором разделе будут размещены наши данные. Я решил выбрать файловую систему btrfs, поскольку использую её уже много лет.

Обращаю внимание, что я не использую раздел swap, который часто рекомендуют. Его следовало бы разместить между EFI разделом и root. Но т.к. я знаю, что выделенного мной количества оперативной памяти хватит для всех экспериментов, то от этого раздела я отказался. На компьютерах с большим количеством оперативной памяти, например, 16 ГБ, от swap также можно отказаться и применять zram. При крайней необходимости, можно создать файл подкачки и использовать его. Сделать это возможно в том числе на btrfs, хоть это и не совсем просто. И ещё. Отказ от раздела подкачки сделает невозможным использование спящего режима, когда данные из ОЗУ сохраняются на диск и система полностью отключается.

Форматируем разделы:

```bash
mkfs.fat -F 32 /dev/sda1
mkfs.btrfs /dev/sda2
```

Если у вас используется файл подкачки, то не забудьте его подготовить:

```bash
mkswap /dev/sdXy
```

Для удобства создадим подтома на btrfs: root и home. Раздел root будет корнем нашей файловой системы, home будет хранить домашние папки пользователей (`/home`).

```bash
mount /dev/sda2 /mnt
btrfs subvolume create /mnt/root
btrfs subvolume create /mnt/home
```

После создания подтомов отключим том и подключим вне необходимые для установки разделы создавая при этом необходимые точки монтирования (опция `--mkdir` команды `mount`):

```bash
umount /dev/sda2
mount -o subvol=/root /dev/sda2 /mnt
mount --mkdir -o subvol=/home /dev/sda2 /mnt/home
mount --mkdir /dev/sda1 /mnt/boot
```

Далее необходимо смонтировать swap, если его используете:

```bash
swapon /dev/sdXy
```

В соответствии с инструкцией по установке установим базовые пакеты

```bash
pacstrap -K /mnt base linux linux-firmware
```

Сгенерируем файл /etc/fstab имеющимися в наличии утилитами:

```bash
genfstab -U /mnt >> /mnt/etc/fstab
```

После этого можно перейти в chroot окружение уже установленной системы:

```bash
arch-chroot /mnt
```

Дальше следуем инструкциям из официального мануала касательно часов и заменяем /etc/localtime на символическую ссылку на файл с нужным часовым поясом:

```bash
ln -sf /usr/share/zoneinfo/Регион/Город /etc/localtime
hwclock --systohc
```

Следующим шагом идёт настройка локалей. Однако в нашей системе всё ещё отсутствуют редакторы, поэтому необходимо установить удобный для вас, например, nano или vim, или вообще установить полноценный файловый менеджер mc (Midnight Commander). Установим vim:

```bash
pacman -S vim
```

Редактируем файл `locale.gen` путём удаления комментариев перед `ru_RU.UTF-8` или другой необходимой, генерируем необходимые файлы и устанавливаем нужную локаль:

```bash
vim /etc/locale.gen
locale-gen
echo "LANG=ru_RU.UTF-8" > /etc/locale.conf
```

Для возможности отображения кириллицы необходимо использовать шрифт с её поддержкой. Это можно сделать в файле `/etc/vconsole.conf`:

```ini
FONT=cyr-sun16
KEYMAP=ru
```

Установим имя хоста (для примера, `archlinux`)

```bash
echo "archlinux.local" > /etc/hostname
```

Установим пакеты `grub` и `efibootmgr`. `efibootmgr` нужен для установки Grub на системах с EFI:

```bash
pacman -S grub efibootmgr
```

Установим Grub на диск и создадим для него конфигурацию:

```bash
grub-install --efi-directory=/boot
grub-mkconfig -o /boot/grub/grub.cfg
```

Теперь необходимо задать пароль для пользователя root или, лучше, создать своего пользователя и разрешить ему запуск процессов через sudo.

Если вы решили задать пользователю root пароль, то просто выполните

```bash
passwd
```

После этого можно перезагрузить машину. Но это не самый лучший, с точки зрения безопасности, вариант.

Создадим нового пользователя, при этом, добавим его в группу wheel и создадим домашнюю папку по умолчанию, а также создадим пароль:

```bash
useradd my_user -G wheel -m
passwd my_user
```

Установим пакет sudo и разрешим группе wheel его использовать создав файл g_wheel (можно также исправить /etc/sudoers):

```bash
pacman -S sudo
echo "%wheel ALL=(ALL) ALL" > /etc/sudoers.d/g_wheel
```

В качестве сервиса работы с сетью используем networkd из состава systemd (вы можете использовать NetworkManager, netplan.io и другие, по желанию). Чтобы интерфейс с именем `enp0s3` получил автоматические настройки через DHCPD, создадим файл `/etc/systemd/networkd/enp0s3.network` со следующим содержанием:

```ini
[Match]
Name=enp0s3

[Network]
DHCP=yes
```

Активируем сервисы и позволим systemd контролировать адреса используемых DNS серверов заменив /etc/resolv.conf на символическую ссылку:

```bash
systemctl enable systemd-networkd
systemctl enable systemd-resolved
```

На этом можно завершить установку системы, выйти из chroot и перезапустить машину:

```bash
exit
reboot
```

После перезагрузки вы должны попасть в командную строку вашей установленной системы.

Активируем возможность systemd-resolved управлять используемыми серверами DNS.

```bash
ln -sf /run/systemd/resolve/resolv.conf /etc/resolv.conf
```

Если вас не устраивает локаль или имя хоста, то после загрузки системы вы можете изменить их с помощью утилит systemd:

```bash
localectl set-locale en_US.UTF-8
hostnamectl set-hostname archlinux.tavda.net
```

Установите полезные пакеты:

- btrfs-progs - утилиты для обслуживания btrfs;
- mc - файловый менеджер Midnight Commander.

Если у вас возникли проблемы с отображением символов, например, кириллицы, то можно воспользоваться инструкцией [Ранний запуск KMS](https://wiki.archlinux.org/title/Kernel_mode_setting#Early_KMS_start). Инструкция переведена на русский язык, но на момент написания в русскоязычной версии не было имён модулей для графических драйверов QEMU и VirtualBox, поэтому ссылка приведена для англоязычной версии. Выберите необходимый вам драйвер до добавьте его в параметр MODULES файла `/etc/mkinitcpio.conf`, например, для VirtualBox:

```ini
MODULES=(vmwgfx)
```

После этого соберите initramfs:

```bash
mkinitcpio -p linux
```

Несколько замечаний касательно использования VirtualBox. У меня с первого раза это не получилось загрузить систему из-за неверно сконфигурированного grub. При этом я не мог попасть в меню загрузки VirtualBox, чтобы выбрать загрузку с CD. Решил это путём удаления HDD из настроек виртуальной машины, а уже после запуска с CD подключил его обратно. Дальше просто смонтировал файловую систему и перешёл в chroot для исправления своих ошибок.

Второй проблемой, с которой столкнулся - неработающий IPv6. Виртуальная машина получает все необходимые данные по SLAAC, но при этом интернет недоступен. Как оказалось, виной всему режим моста на WiFi адаптере хоста. В этом случае нарушается работа протокола ND, что приводит к неработоспособности IPv6. На своей тестовой машине я просто отказался от IPv6 путём отключения приёма сообщений маршрутизаторов, добавив в секцию `[Network]` файла `/etc/systemd/network/enp0s3.network`:

```ini
[Network]
...
IPv6AcceptRA=no
```

Если вы не используете WiFi на своей хост машине для доступа в сеть, то IPv6 должен нормально работать.

Пока на этом всё. Я получил работающий Archlinux внутри своей виртуальной машины.
