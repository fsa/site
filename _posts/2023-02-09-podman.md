---
layout: post
title: Podman
date: 2023-02-09 01:30:00 +0700
tags: [Podman]
excerpt: Бесплатное программное обеспечение для запуска приложений в контейнерах
---

Почему podman, а не docker? Я использую операционную систему Fedora, где podman давно уже находится в официальных репозиториях, в отличие от docker. Podman легко установить на относительно свежие стабильные версии Ubuntu 22.04 LTS и Debian 11. Кроме этого, podman создавался с целью избавиться от недостатков docker в виде необходимости использования демона и работы от root. Контейнеры для podman можно создавать от имени обычного пользователя, а запускать их можно с помощью systemd.

Для создания контейнера необходимо образ, который можно взять из репозиториев. Поиск по доступным репозиториям осуществляется с помощью команды

```bash
podman search ИМЯ_ОБРАЗА
```

Можно использовать фильтры, например, искать только образы, которые помечены как официальные, от разработчиков продукта:

```bash
podman search ИМЯ_ОБРАЗА --filter=is-official
```

Вытянуть нужный образ можно так

```bash
podman pull httpd
```

Поскольку указано только имя пакета, будет предложен выбор из какого репозитория этот пакет необходимо скачать или будет скачан образ из доступных репозиториев. Однако, лучше указать и полное имя, чтобы избежать возможных разночтений

```bash
podman pull docker.io/library/httpd
```

Просмотреть все загруженные образы можно с помощью команды

```bash
podman images
```

Удалить образы можно двумя способами: указав имя репозитория или указать ID образа указанное в списке загруженных образов.

```bash
podman rmi pull docker.io/library/php
podman rmi 68dd7c965170
```

Запустить контейнер можно следующим образом:

```bash
podman run [options] image [command [arg ...]]
```

Можно использовать опции при запуске, что будет рассмотрено позже. Также требуется указать образ, который будет использован для запуске - image. Подробнее о том, как задаётся имя образа можно почитать в документации. Если вы укажете в виде имени образа образ из удалённого репозитория, например, `docker.io/library/php`, то файл будет скачан из удалённого репозитория так, как будь-то вы выполнили команду `podman pull` ранее.

Опционально вы можете задать имя команды при запуске контейнера и аргументов для неё. Например

```bash
podman run -it --rm --name jekyll \
  -v ./:/srv/jekyll:rw,slave,Z \
  --publish 4000:4000 \
  -e JEKYLL_UID=1000 \
  -e JEKYLL_GID=1000 \
  docker.io/jekyll/jekyll:4 \
  jekyll serve --drafts
```

Был использовать контейнер `docker.io/jekyll/jekyll` 4 версии и при запуске была выполнена команда с параметрами `jekyll serve --drafts`.

Просмотреть список запущенных контейнеров можно при помощи

```bash
podman ps
```

Посмотреть список всех контейнеров, доступных для запуска и запущенных

```bash
podman ps -a
```

```bash
podman run --rm --detach \
    --name toms-mongo \
    --volume /var/lib/mongo:/data/db:Z \
    docker.io/library/mongo
```

Флаг Z для меня важен, т.к. он отвечает за то, что  SELinux пометит каталог, чтобы пользователь контейнера мог писать в него.

Сгенерировать юнит systemd с помощью команды

```bash
podman generate systemd --new --name NAME
```

Она выведет текст unit-файла на экран. Можно сразу сохранить его в `/etc/systemd/system/` или `~/.config/systemd/user/` необходимого пользователя. Не забудьте, что вам могу потребоваться соответствующие права для записи.

```bash
podman generate systemd --new --name NAME > /etc/systemd/system/NAME.service
```

Активировать и запустить сервис можно с помощью команды

```bash
sudo systemd enable --now NAME.service
```

Если вы планируете запускать контейнер от имени пользователя, то

```bash
systemd enable --user --now NAME.service
```

Однако пользовательский процесс systemd запускается сразу после первого входа пользователя в систему, и будет убит после завершения последнего сеанса пользователя. Иногда может быть полезно запустить службу сразу после загрузки, и поддерживать процесс systemd запущенным даже после завершения последнего сеанса пользователя, например, чтобы некоторый пользовательский процесс работал без какой-либо открытой сессии. Для этой цели используются долговременные службы. Используйте следующую команду, чтобы включить долговременную службу для конкретного пользователя с именем username:

```bash
loginctl enable-linger username
```
