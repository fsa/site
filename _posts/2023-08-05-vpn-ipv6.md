---
layout: post
title: Свой собственный VPN с поддержкой IPv6
date: 2023-05-18 23:15:00 +0700
tags: [VPN, IPv6, Wireguard]
excerpt: Создание собственного VPN сервера для получения доступа к интернет с поддержкой IPv6.
published: false
---

Иногда, когда вы обучаетесь в интернете самостоятельно, возникает необходимость получить доступ к сайтам, например, <https://refactoring.guru>, но по каким-то причинам этот сайт заблокирован в вашей стране. Выходом может стать VPN. Однако покупать VPN где-то на стороне при наличии собственного VPS сервера бессмысленно, да и собственный VPS на время обучения обойдётся достаточно дёшево. В таком случае возникает вопрос: а как, собственно организовать этот самый VPN.

Одним из популярных вариантов является Wireguard. Сам по себе, Wireguard, довольно прост. Его можно использовать в любых схемах: «точка-точка», «звезда» и даже mesh-сеть. В нашем варианте нам подойдёт вариант даже «точка-точка». Но это вариант легко расширяется до схемы «звезда», который, собственно и будем реализовывать.

Если с IPv4 всё понятно, поскольку большинство руководств, которые можно найти в интернете сходятся к одному решению - использованию серой адресации с NAT на сервере. Это стандартная схема для IPv4 адресации. Адресов IPv4 мало и стоят они дорого, поэтому никто в здравом уме не будет использовать «белые» адреса непосредственно на устройствах, если это не сервер, который доступен в интернете. А вот с IPv6 не всё так однозначно.

Сам по себе протокол IPv6 строится на том, что никому не потребуется использовать NAT. При этом это не означает, что сам по себе NAT в IPv6 недоступен. Вы им можете пользоваться, но его использование не рекомендуется, а в некоторых случаях это даже вредно.

Выдавать IPv6 хостинг-провайдеры тоже могут по разному. Из вариантов:

1. Выдача IPv6 адресов поштучно. Самый странный вариант. Если у вашего хостинг-провайдера так, что, скорее всего, стоит просто сменить его на другого.
2. Выдача сети /64. Наиболее часто встречающийся вариант для дешёвых провайдеров. Иногда есть возможность через поддержку получить /63 или даже сеть ещё большего размера. Тоже не самый хороший вариант для VPN, но уже терпимо.
3. Вариант не особо отличается от предыдущего, но вместо сети /64 вам выдают сеть до /48, т.е. в вашем распоряжении оказывается адресация некоторого количества сетей /64, точнее до 65536 штук при варианте /48.
4. Маршрутизация определённого префикса IPv6 на вашу виртуальную машину. Мне такие сервисы не попадались, но, возможно, можно получить подобное через поддержку. Этот вариант подразумевает, что ваш хостинг провайдер прописал маршрут на ваш виртуальный сервер для выделенного вам префикса. В этом случае у вас может в руках оказаться сеть от /64 до /48 (или, даже, другие, но выдавать меньше /64 бессмысленно), которые без костылей могут быть использованы вами для организации VPN.

Сложность настройки VPN постепенно уменьшается от 1 до 4 варианта, поэтому начнём с 4 варианта и постепенно поднимемся вверх.

## Шаг 1: Настройка маршрутизации на сервере VPN

Самым простым вариантом настройки является вариант, когда ваш провайдер прописал маршрут для сети или сетей /64 на вашу виртуальную машину. В таком случае единственное, что вам нужно будет сделать, чтобы обеспечить работу VPN - это включить маршрутизацию на вашей машине.

Для IPv4 маршрутизация включается с помощью sysctl путём установки

```ini
net.ipv4.ip_forward=1
```

Для IPv6 это делается аналогично:

```ini
net.ipv6.conf.all.forwarding = 1
```

Но есть одно НО! Если ваша машина получает адреса в автоматическом режиме, то после включения маршрутизации она перестанет принимать анонсы от маршрутизаторов, а, значит, больше не сможет получить адрес в автоматическом режиме. Чтобы это исправить, включите

```ini
net.ipv6.conf.ens3.accept_ra = 2
```

В данном примере `ens3` - это сетевой интерфейс нашего VPS, откуда мы хотим принимать анонсы маршрутизатора. На большинстве хостингов, которые мне попадались, назначение IPv6 адресов на VPS производилось путём прописывания их в настройках сетевого интерфейса, а значит, то и принимать RA не требуется, т.е. данную настройку можно пропустить.

Теперь осталось выделить сеть /64 и доступного вам диапазона, назначить один из адресов на интерфейс wireguard на VPS, а также выдать каждому клиенту по IPv6 адресу из этого же диапазона. На этом настройка VPN для 4 варианта будет закончена.

## Шаг 2: Обеспечиваем маршрутизацию пакетов, необходимых для VPN

Теперь перейдём к варианту, когда нам выделено в лучшем случае от /63 до /48, и в худшем /64. Сначала рассмотрим лучший вариант.

Первое, что необходимо проверить, что сетевой интерфейс вашего сервера настроен на сеть стандартного размера /64. В этом случае вы можете использовать адресацию нулевого диапазона вашего префикса для адресации вашего сервера, а любой из остальных доступных использовать для вашего VPN соединения. Настраиваем всё аналогично. Но есть одна проблема.

В IPv6 есть замечательная функция - обнаружение соседей. Это означает, что если хост хочет с кем-то связаться, то в первую очередь отправляет запрос, что адрес назначения случаем не является моим соседом. Если в ответ будет получен ответ, то хост сможет направить данные напрямую, минуя маршрутизатор. Если хост недоступен, то хост воспользуется таблицей маршрутизации и отправить пакет на соответствующий маршрутизатор. Эта ситуация немного необычна для IPv4. В IPv6 пакеты между разными диапазонами могут ходить напрямую между хостами, а также существуют ситуации, когда даже хосты в одной сети будут общаться через маршрутизатор.

Поскольку мы назначили для своего сервера сеть /64, то при попытке маршрутизатора провайдера найти соседей наш хост будет эти запросы игнорировать. Чтобы этого не происходило, можно воспользоваться специальной службой NDP proxy. Этот сервис может выдавать ответы на поиск соседей и отвечать, что адрес принадлежит ему. При этом он может запрос поиска соседа передавать на другие свои сетевые интерфейсы. К сожалению, Wireguard работает на более высоком уровне. Поэтому единственным вариантом для нас остаётся настроить так, что при запросе нужных нам адресов мы будем просто всегда отвечать, что адрес принадлежит нам.

Одним из вариантов решения данной проблемы - это установка пакета `ndppd`. Пакет точно доступен в стандартных поставках Ubuntu и Fedora в официальных репозиториях. Установите его с помощью вашего пакетного менеджера. Конфигурация `ndppd` достаточно простая. Расположен файл конфигурации в `/etc/ndppd.conf`.

```console
proxy ens3 {
    rule 2001:0db8:827:fcde:cafb:073d:a65e:25b0 {
        static
    }
}
```

Данная конфигурация означает, что если приходит запрос на интерфейс `ens3` с запросом соседа по адресу `2001:0db8:827:fcde:cafb:073d:a65e:25b0`, то необходимо ответить, что это мы. Записи `rule` можно повторить несколько раз и даже указать целый диапазон. Однако сам `ndppd` не приветствует широкую маску сети, поскольку это чрезвычайно проблемами на маршрутизаторе, если найдётся какой-то злоумышленник. Он просто может обратиться ко множеству адресов из вашего диапазона, поэтому маршрутизатору провайдера придётся записывать в таблицу соседей все эти адреса, что может привести с снижению производительности маршрутизатора, а также другими проблемами.

## Шаг 2.1: Что делать, если у нас только сеть /64

Это самый неблагоприятный вариант, но при этом мы всё равно сможем обеспечить работу нашего VPN. Вообще сама идея разделять диапазон /64 на сети меньшего размера, мягко говоря, не приветствуется. Но поскольку у нас нет другого выхода, то придётся это сделать. Сразу скажу, это грязный хак!

Поскольку мы используем VPS, то вряд ли будем использовать механизм SLAAC. К тому же в большинстве случаев адресация для VPS прописывается вручную, просто потому, что у сервера должен быть строго определённый адрес. Исходя из этого можно разделить сеть /64 на сети меньшего размера. Как делить? Если вы не планируете запускать на сервере другие сервисы VPN, то самым оптимальным вариантом являются сети /65. В этом случае для клиентов VPN нам доступны почти все биты из диапазона /64, кроме старшего. При таком разделении наш адрес будет выглядеть как обычный адрес, который был выделен через SLAAC.

Если кроме Wireguard вы хотите, например, также запустить на вашем сервере также OpenVPN, то вам может понадобиться ещё одна сеть для этого сервиса. В таком случае вы можете выбрать сеть /66. Конечно, в этом случае вам нужно учитывать уже не один старший бит, а два. Можно и дальше сужать сети, но при этом адреса ваших клиентов будут уже не так похожи на адреса, которые обычно выделяются при использовании механизма SLAAC. В дальнейшем я ограничу повествование использованием сети /65.

Чтобы ваш сервер обеспечил маршрутизацию пакетов, которые вам необходимо будет отправить клиенту VPN, необходимо урезать сеть в настройках сетевого интерфейса. Вместо /64 указываем выбранную маску, например /65. После этого настройка вашего VPN сервера не отличается от настроек, которые мы делали на шаге 2. Конечно, маску /65 нужно указать в настройках Wireguard на вашем сервере.

## Практическая часть

Дабы не вдаваться в подробности, будем считать, что вы ознакомились с моей [«Шпаргалкой по Wireguard»](https://tavda.net/wireguard) или любой другой инструкции, которых очень много в интернете, и вам не надо объяснять как генерировать ключи.

Включаем маршрутизацию на VPS путём установки параметров, например, путём добавления файла `/etc/sysctl.d/20-vpn.conf` и загрузки их через `sysctl -p`:

```ini
net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding = 1
```

Сгенерируйте пару ключей для своего VPN сервера, например так

```bash
wg genkey | tee private.key | wg pubkey > public.key
```

Для дополнительной безопасности для каждого клиента может быть сгенерирован ключ PSK, но это не обязательно:

```bash
wg genpsk > psk.key
```

Аналогичным образом сгенерируйте ключи для всех ваших клиентов. После этого можно сформировать серверную конфигурацию для Wireguard.

```ini
[Interface]
Address = 192.168.0.1/24, 2001:0db8:827:fcde::1/64
PrivateKey = <SERVER_PRIVATE_KEY>
ListenPort = <SERVER_PORT>

[Peer]
PublicKey = <CLIENT_PUBLIC_KEY>
AllowedIPs = 192.168.0.2, 2001:0db8:827:fcde::1ce:1ce:babe
PresharedKey = <PRESHARED_KEY>
```

Не сложно догадаться, что `<SERVER_PRIVATE_KEY>` - это закрытый ключ сервера, а `<CLIENT_PUBLIC_KEY>` - это публичный ключ клиента. `192.168.0.0/24` - это сеть IPv4 для нашего подключения, а адрес `192.168.0.1` будет присвоен интерфейсу Wireguard. По аналогии, `2001:0db8:827:fcde::/64`, соответственно сеть IPv6, а адрес `2001:0db8:827:fcde::1` - адрес интерфейса Wireguard. Опция `PresharedKey` не обязательная, но если она указана на сервере, то она также должна быть указана в конфигурации клиента.

Секция `[Peer]` должна быть создана для каждого клиента. В `AllowedIPs` должны быть указаны IP адреса, которые мы ожидаем от клиента.

Конфигурации клиентов должны иметь вид

```ini
[Interface]
Address = 192.168.0.2, 2001:0db8:827:fcde::1ce:1ce:babe
PrivateKey = <CLIENT_PRIVATE_KEY>

[Peer]
PublicKey = <SERVER_PUBLIC_KEY>
AllowedIPs = 192.168.0.0/24, 2000::/3
Endpoint = <SERVER_NAME>:<SERVER_PORT>
PresharedKey = <PRESHARED_KEY>
PersistentKeepalive = 20
```

Аналогично, на клиенте `CLIENT_PRIVATE_KEY` - закрытый ключ клиента, `SERVER_PUBLIC_KEY` - публичный ключ сервера. В `Endpoint` необходмио указать адрес `SERVER_NAME` и порт `SERVER_PORT` сервера, которые соответствуют указанным параметрам в настройках сервера. Параметр `PresharedKey` должен присутствовать, если он есть в секции `[Peer]` для этого клиента, содержимое ключа должно совпадать.

`PersistentKeepalive` может также отсутствовать. Но если указано, то клиент каждые 20 секунд (или любое другое количество, которое будет указано) будет отправлять пакет данных. Это полезно в тех случаях, когда клиент находится за NAT или Firewall, которые при отсутствии активности могут запретить удалённому хосту присылать вам ответы.

Чтобы обеспечить доступ клиентов в интернет по протоколу IPv4, необходимо включать и отключать NAT, например, с помощью скриптов, которые необходимо добавить в секцию `[Interface]` на сервере.

```ini
PostUp = iptables -A FORWARD -i %i -j ACCEPT -w 10; iptables -t nat -A POSTROUTING -o ens3 -j MASQUERADE -w 10
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -t nat -D POSTROUTING -o ens3 -j MASQUERADE
```

## Автоматизация

Конечно, делать все необходимые настройки руками, особенно если новый клиент вашего VPN появляется не часто, это просто сущее наказание. Поэтому я задумался об автоматизации. 